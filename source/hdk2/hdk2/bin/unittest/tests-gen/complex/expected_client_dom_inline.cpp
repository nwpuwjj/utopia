/*
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2015 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**********************************************************************
   Copyright [2014] [Cisco Systems, Inc.]
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************/

/*
 * Copyright (c) 2008-2010 Cisco Systems, Inc. All rights reserved.
 *
 * Cisco Systems, Inc. retains all right, title and interest (including all
 * intellectual property rights) in and to this computer program, which is
 * protected by applicable intellectual property laws.  Unless you have obtained
 * a separate written license from Cisco Systems, Inc., you are not authorized
 * to utilize all or a part of this computer program for any purpose (including
 * reproduction, distribution, modification, and compilation into object code),
 * and you must immediately destroy or return to Cisco Systems, Inc. all copies
 * of this computer program.  If you are licensed by Cisco Systems, Inc., your
 * rights to utilize this computer program are limited by the terms of that
 * license.  To obtain a license, please contact Cisco Systems, Inc.
 *
 * This computer program contains trade secrets owned by Cisco Systems, Inc.
 * and, unless unauthorized by Cisco Systems, Inc. in writing, you agree to
 * maintain the confidentiality of this computer program and related information
 * and to not disclose this computer program and related information to any
 * other person or entity.
 *
 * THIS COMPUTER PROGRAM IS PROVIDED AS IS WITHOUT ANY WARRANTIES, AND CISCO
 * SYSTEMS, INC. EXPRESSLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
 * INCLUDING THE WARRANTIES OF MERCHANTIBILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE, AND NONINFRINGEMENT.
 */

// actual_client_dom_inline.cpp - [Generated by hdkcli_cpp]

// Local header.
#include "actual_client_dom_inline.h"

using namespace HDK;

bool HDK::InitializeClient() throw()
{
    return !!HDK_CLI_Init();
}

void HDK::UninitializeClient() throw()
{
    HDK_CLI_Cleanup();
}

HDK::ClientError Cisco_HNAP::GetServiceInfo
(
    HDK::ITarget* pTarget,
    const Cisco_HNAP::GetServiceInfoStruct & input,
    Cisco_HNAP::GetServiceInfoResponseStruct & output,
    enum Cisco_HNAP::GetServiceInfoResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_GetServiceInfo,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_GetServiceInfo);

    // Get the result value.
    enum Cisco_HNAP::GetServiceInfoResult result = output.get_GetServiceInfoResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Cisco_HNAP::GetServices
(
    HDK::ITarget* pTarget,
    Cisco_HNAP::GetServicesResponseStruct & output,
    enum Cisco_HNAP::GetServicesResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Cisco_HNAP::GetServicesStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_GetServices,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_GetServices);

    // Get the result value.
    enum Cisco_HNAP::GetServicesResult result = output.get_GetServicesResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::AddPortMapping
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::AddPortMappingStruct & input,
    enum Purenetworks_HNAP1::AddPortMappingResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::AddPortMappingResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_AddPortMapping,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_AddPortMapping);

    // Get the result value.
    enum Purenetworks_HNAP1::AddPortMappingResult result = output.get_AddPortMappingResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::DeletePortMapping
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::DeletePortMappingStruct & input,
    enum Purenetworks_HNAP1::DeletePortMappingResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::DeletePortMappingResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_DeletePortMapping,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_DeletePortMapping);

    // Get the result value.
    enum Purenetworks_HNAP1::DeletePortMappingResult result = output.get_DeletePortMappingResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::DownloadSpeedTest
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::DownloadSpeedTestStruct & input,
    Purenetworks_HNAP1::DownloadSpeedTestResponseStruct & output,
    enum Purenetworks_HNAP1::DownloadSpeedTestResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_DownloadSpeedTest,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_DownloadSpeedTest);

    // Get the result value.
    enum Purenetworks_HNAP1::DownloadSpeedTestResult result = output.get_DownloadSpeedTestResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::FirmwareUpload
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::FirmwareUploadStruct & input,
    enum Purenetworks_HNAP1::FirmwareUploadResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::FirmwareUploadResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_FirmwareUpload,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_FirmwareUpload);

    // Get the result value.
    enum Purenetworks_HNAP1::FirmwareUploadResult result = output.get_FirmwareUploadResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetClientStats
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetClientStatsResponseStruct & output,
    enum Purenetworks_HNAP1::GetClientStatsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetClientStatsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetClientStats,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetClientStats);

    // Get the result value.
    enum Purenetworks_HNAP1::GetClientStatsResult result = output.get_GetClientStatsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetConfigBlob
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetConfigBlobResponseStruct & output,
    enum Purenetworks_HNAP1::GetConfigBlobResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetConfigBlobStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetConfigBlob,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetConfigBlob);

    // Get the result value.
    enum Purenetworks_HNAP1::GetConfigBlobResult result = output.get_GetConfigBlobResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetConnectedDevices
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetConnectedDevicesResponseStruct & output,
    enum Purenetworks_HNAP1::GetConnectedDevicesResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetConnectedDevicesStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetConnectedDevices,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetConnectedDevices);

    // Get the result value.
    enum Purenetworks_HNAP1::GetConnectedDevicesResult result = output.get_GetConnectedDevicesResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetDeviceSettings
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetDeviceSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetDeviceSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetDeviceSettingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetDeviceSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetDeviceSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetDeviceSettingsResult result = output.get_GetDeviceSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetDeviceSettings_GET
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetDeviceSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetDeviceSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetDeviceSettingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_GET_PN_GetDeviceSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_GET_PN_GetDeviceSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetDeviceSettingsResult result = output.get_GetDeviceSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetDeviceSettings2
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetDeviceSettings2ResponseStruct & output,
    enum Purenetworks_HNAP1::GetDeviceSettings2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetDeviceSettings2Struct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetDeviceSettings2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetDeviceSettings2);

    // Get the result value.
    enum Purenetworks_HNAP1::GetDeviceSettings2Result result = output.get_GetDeviceSettings2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetFirmwareSettings
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetFirmwareSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetFirmwareSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetFirmwareSettingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetFirmwareSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetFirmwareSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetFirmwareSettingsResult result = output.get_GetFirmwareSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetMACFilters2
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetMACFilters2ResponseStruct & output,
    enum Purenetworks_HNAP1::GetMACFilters2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetMACFilters2Struct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetMACFilters2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetMACFilters2);

    // Get the result value.
    enum Purenetworks_HNAP1::GetMACFilters2Result result = output.get_GetMACFilters2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetNetworkStats
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetNetworkStatsResponseStruct & output,
    enum Purenetworks_HNAP1::GetNetworkStatsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetNetworkStatsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetNetworkStats,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetNetworkStats);

    // Get the result value.
    enum Purenetworks_HNAP1::GetNetworkStatsResult result = output.get_GetNetworkStatsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetPortMappings
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetPortMappingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetPortMappingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetPortMappingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetPortMappings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetPortMappings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetPortMappingsResult result = output.get_GetPortMappingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetRouterLanSettings2
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetRouterLanSettings2ResponseStruct & output,
    enum Purenetworks_HNAP1::GetRouterLanSettings2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetRouterLanSettings2Struct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetRouterLanSettings2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetRouterLanSettings2);

    // Get the result value.
    enum Purenetworks_HNAP1::GetRouterLanSettings2Result result = output.get_GetRouterLanSettings2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetRouterSettings
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetRouterSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetRouterSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetRouterSettingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetRouterSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetRouterSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetRouterSettingsResult result = output.get_GetRouterSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWLanRadioFrequencies
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetWLanRadioFrequenciesResponseStruct & output,
    enum Purenetworks_HNAP1::GetWLanRadioFrequenciesResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetWLanRadioFrequenciesStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioFrequencies,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioFrequencies);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWLanRadioFrequenciesResult result = output.get_GetWLanRadioFrequenciesResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWLanRadioSecurity
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::GetWLanRadioSecurityStruct & input,
    Purenetworks_HNAP1::GetWLanRadioSecurityResponseStruct & output,
    enum Purenetworks_HNAP1::GetWLanRadioSecurityResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioSecurity,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioSecurity);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWLanRadioSecurityResult result = output.get_GetWLanRadioSecurityResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWLanRadioSettings
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::GetWLanRadioSettingsStruct & input,
    Purenetworks_HNAP1::GetWLanRadioSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetWLanRadioSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadioSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWLanRadioSettingsResult result = output.get_GetWLanRadioSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWLanRadios
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetWLanRadiosResponseStruct & output,
    enum Purenetworks_HNAP1::GetWLanRadiosResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetWLanRadiosStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadios,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWLanRadios);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWLanRadiosResult result = output.get_GetWLanRadiosResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWanInfo
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetWanInfoResponseStruct & output,
    enum Purenetworks_HNAP1::GetWanInfoResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetWanInfoStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWanInfo,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWanInfo);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWanInfoResult result = output.get_GetWanInfoResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::GetWanSettings
(
    HDK::ITarget* pTarget,
    Purenetworks_HNAP1::GetWanSettingsResponseStruct & output,
    enum Purenetworks_HNAP1::GetWanSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::GetWanSettingsStruct input;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWanSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_GetWanSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::GetWanSettingsResult result = output.get_GetWanSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::IsDeviceReady
(
    HDK::ITarget* pTarget,
    enum Purenetworks_HNAP1::IsDeviceReadyResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::IsDeviceReadyStruct input;

    Purenetworks_HNAP1::IsDeviceReadyResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_IsDeviceReady,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_IsDeviceReady);

    // Get the result value.
    enum Purenetworks_HNAP1::IsDeviceReadyResult result = output.get_IsDeviceReadyResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::Reboot
(
    HDK::ITarget* pTarget,
    enum Purenetworks_HNAP1::RebootResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::RebootStruct input;

    Purenetworks_HNAP1::RebootResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_Reboot,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_Reboot);

    // Get the result value.
    enum Purenetworks_HNAP1::RebootResult result = output.get_RebootResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::RenewWanConnection
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::RenewWanConnectionStruct & input,
    enum Purenetworks_HNAP1::RenewWanConnectionResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::RenewWanConnectionResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_RenewWanConnection,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_RenewWanConnection);

    // Get the result value.
    enum Purenetworks_HNAP1::RenewWanConnectionResult result = output.get_RenewWanConnectionResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::RestoreFactoryDefaults
(
    HDK::ITarget* pTarget,
    enum Purenetworks_HNAP1::RestoreFactoryDefaultsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }
    Purenetworks_HNAP1::RestoreFactoryDefaultsStruct input;

    Purenetworks_HNAP1::RestoreFactoryDefaultsResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_RestoreFactoryDefaults,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_RestoreFactoryDefaults);

    // Get the result value.
    enum Purenetworks_HNAP1::RestoreFactoryDefaultsResult result = output.get_RestoreFactoryDefaultsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetAccessPointMode
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetAccessPointModeStruct & input,
    Purenetworks_HNAP1::SetAccessPointModeResponseStruct & output,
    enum Purenetworks_HNAP1::SetAccessPointModeResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetAccessPointMode,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetAccessPointMode);

    // Get the result value.
    enum Purenetworks_HNAP1::SetAccessPointModeResult result = output.get_SetAccessPointModeResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetConfigBlob
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetConfigBlobStruct & input,
    enum Purenetworks_HNAP1::SetConfigBlobResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetConfigBlobResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetConfigBlob,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetConfigBlob);

    // Get the result value.
    enum Purenetworks_HNAP1::SetConfigBlobResult result = output.get_SetConfigBlobResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetDeviceSettings
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetDeviceSettingsStruct & input,
    enum Purenetworks_HNAP1::SetDeviceSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetDeviceSettingsResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetDeviceSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetDeviceSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::SetDeviceSettingsResult result = output.get_SetDeviceSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetDeviceSettings2
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetDeviceSettings2Struct & input,
    enum Purenetworks_HNAP1::SetDeviceSettings2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetDeviceSettings2ResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetDeviceSettings2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetDeviceSettings2);

    // Get the result value.
    enum Purenetworks_HNAP1::SetDeviceSettings2Result result = output.get_SetDeviceSettings2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetMACFilters2
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetMACFilters2Struct & input,
    enum Purenetworks_HNAP1::SetMACFilters2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetMACFilters2ResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetMACFilters2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetMACFilters2);

    // Get the result value.
    enum Purenetworks_HNAP1::SetMACFilters2Result result = output.get_SetMACFilters2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetRouterLanSettings2
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetRouterLanSettings2Struct & input,
    enum Purenetworks_HNAP1::SetRouterLanSettings2Result* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetRouterLanSettings2ResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetRouterLanSettings2,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetRouterLanSettings2);

    // Get the result value.
    enum Purenetworks_HNAP1::SetRouterLanSettings2Result result = output.get_SetRouterLanSettings2Result();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetRouterSettings
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetRouterSettingsStruct & input,
    enum Purenetworks_HNAP1::SetRouterSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetRouterSettingsResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetRouterSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetRouterSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::SetRouterSettingsResult result = output.get_SetRouterSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetWLanRadioFrequency
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetWLanRadioFrequencyStruct & input,
    enum Purenetworks_HNAP1::SetWLanRadioFrequencyResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetWLanRadioFrequencyResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioFrequency,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioFrequency);

    // Get the result value.
    enum Purenetworks_HNAP1::SetWLanRadioFrequencyResult result = output.get_SetWLanRadioFrequencyResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetWLanRadioSecurity
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetWLanRadioSecurityStruct & input,
    enum Purenetworks_HNAP1::SetWLanRadioSecurityResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetWLanRadioSecurityResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioSecurity,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioSecurity);

    // Get the result value.
    enum Purenetworks_HNAP1::SetWLanRadioSecurityResult result = output.get_SetWLanRadioSecurityResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetWLanRadioSettings
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetWLanRadioSettingsStruct & input,
    enum Purenetworks_HNAP1::SetWLanRadioSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetWLanRadioSettingsResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWLanRadioSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::SetWLanRadioSettingsResult result = output.get_SetWLanRadioSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}

HDK::ClientError Purenetworks_HNAP1::SetWanSettings
(
    HDK::ITarget* pTarget,
    const Purenetworks_HNAP1::SetWanSettingsStruct & input,
    enum Purenetworks_HNAP1::SetWanSettingsResult* presult /* = NULL */,
    unsigned int timeoutSecs /* = 0 */
) throw()
{
    if (!pTarget)
    {
        return ClientError_InvalidArg;
    }

    Purenetworks_HNAP1::SetWanSettingsResponseStruct output;

    ClientError error = pTarget->Request(timeoutSecs,
                                         ACTUAL_CLIENT_DOM_MOD_Module(),
                                         ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWanSettings,
                                         input,
                                         &output);

    const HDK_MOD_Method* pMethod = HDK_MOD_GetMethod(ACTUAL_CLIENT_DOM_MOD_Module(), ACTUAL_CLIENT_DOM_MOD_MethodEnum_PN_SetWanSettings);

    // Get the result value.
    enum Purenetworks_HNAP1::SetWanSettingsResult result = output.get_SetWanSettingsResult();
    if (NULL != presult)
    {
        *presult = result;
    }

    // Determine if there was an HNAP-result, and whether it was an error or not.
    if ((ClientError_OK == error) && (HDK_XML_BuiltinElement_Unknown != pMethod->hnapResultElement))
    {
        if ((pMethod->hnapResultOK != (int)result) && (pMethod->hnapResultREBOOT != (int)result))
        {
            // An HNAP error response.
            error = HDK::ClientError_HnapMethod;
        }
    }

    return error;
}
